--return if the anticheat already ran
if shared.AnticheatBypass1Success then return;end;
--get the B.A.C script
local BAC = (function()
    for I, Script in next, game:GetDescendants() do
        if typeof(Script) == "Instance" and Script.ClassName == "LocalScript" then
            if Script.Name:match("B%.A%.C") then
                return Script;
            end;
        end;
    end;
end)();

--get garbage collection
local Collection = getgc(false);

local DONE = false;

(function()

    local BAC_Collection = {};

    for _, Func in next, Collection do
        --loop through garbage collection
        pcall(coroutine.wrap(function()
            --if the current item isn't a function, return
            if type(Func) ~= "function" then return end;
            --if the current item isn't a lua function, return (if it is a C function)
            if not islclosure(Func) then return end;
            
            --this is a workaround to getfenv(Func).script, which triggers the game's anticheat(god knows how)
            local env = getfenv(Func);
            local scr;
            if type(env) == "table" then
                for i,v in next, env do
                    if type(i) == "string" and i == "script" then
                        scr = v;
                        break;
                    end;
                end;
            end;
            
            --if there is no script or script has no parent, return
            if not scr or not scr.Parent then return end;
            
            --if the script is B.A.C, insert it into BAC_Collection
            if scr == BAC then
                table.insert(BAC_Collection, Func);
            end;
        end));

    end;
    --BAC_Collection now contains every Lua function in the B.A.C script

    --get the IsValid function. we could also do (if getinfo(Func).name == "IsValid")
    local IsValid;
    for _, Func in next, BAC_Collection do
        if (table.find(debug.getconstants(Func), "rbxassetid://")) then
            IsValid = Func;
            break;
        end;
    end;

    --loop through BAC_Collection to find the function which has IsValid in it's upvalues
    for _, Func in next, BAC_Collection do
        local index = (table.find(debug.getupvalues(Func), IsValid));
        if index then
            --if this function has IsValid in it's upvalues, set that upvalue to a custom function
            setupvalue(Func, index, function(...)
                local Args = {...};
                --this checks if the ID the game is validating follows rbxassetid://(NUMBERS)
                --most ids that will kick you follow this format, so we will set it to a font so the game thinks it is a valid ID
                if Args[1]:match("rbxassetid://([%d]+)") then
                    Args[1] = "rbxasset://fonts/ariel.ttf";
                end;
                --call the function with the new args (if modified), and return the result
                return IsValid(table.unpack(Args));
            end);
            --setting DONE to true will stop the loop and AnticheatBypass1Success will make sure that this script is only ran once
            DONE = true;
            shared.AnticheatBypass1Success = true;
            return;
        end;
    end;

end)();
print("Bypassed")
local Lib = loadstring(game:HttpGet"https://gitlab.com/te4224/Scripts/-/raw/main/Pulse/UILIB/V1/main.lua")();
local Gui = Lib.new("Quit Camping", UDim2.fromOffset(400, 450));
local Tab = Gui:NewTab("Main");
local Label = Tab:NewLabel("Farm");
local Button = Tab:NewButton("AutoFarm", function() --HBE
local mt = getrawmetatable(game);
make_writeable(mt);
local old_index = mt.__index;

mt.__index = function(a, b)
if tostring(a) == "HumanoidRootPart" then
if tostring(b) == "Size" then
return Vector3.new(2, 2, 1);
end
end
return old_index(a, b);
end


if shared.ShushHighlight then shared.ShushHighlight.stop();end;

local Connection = {};
Connection.__index = Connection;
Connection.__tostring = function(self)
	return self.Name;
end;

Connection.new = function(Event, Func, Once)
	return setmetatable({Name = Event.Name .. ".Connection", Event = Event, Func = Func, Once = Once}, Connection);
end;

Connection.Disconnect = function(self)
	table.remove(self.Event._connections, table.find(self.Event._connections, self));
end;


local Event = {};
Event.__index = Event;
Event.__tostring = function(self)
	return self.Name;
end;

Event.new = function(Name)
	return setmetatable({Name = Name or "Event", _connections={}, _waits={}}, Event);
end;

Event.Connect = function(self, Func)
	local connection = Connection.new(self, Func);
	table.insert(self._connections, connection);
	return connection;
end;
Event.Fire = function(self, ...)
	local Args = {...};
	task.spawn(function()
		for I, Con in next, self._connections do
			Con.Func(unpack(Args));
		end;
	end);
end;


local Target;

local PlayerService = game:GetService("Players");
local LP = PlayerService.LocalPlayer;

local FFC = game.FindFirstChild;

local TargetObject = LP:WaitForChild("PlayerGui").ScreenGui.UI.Target;
local TargetText = TargetObject.TargetText;

do
    local T = TargetText.Text;
    local V = TargetText.Visible;
    local V2 = TargetObject.Visible;

    if V and V2 then
        if T and #T > 1 then
            Target = FFC(PlayerService, T);
        end;
    end;
end;

local INSTChanged = Event.new("InstChanged");
local TARGETChanged = Event.new("TargetChanged");
local HITBOXChanged = Event.new("HitboxChanged");
local TARGETHITBOXChanged = Event.new("TargetHitboxChanged");

local SettingsProxy = {Target = true};

local INSTProxy = {
    FillColor = Color3.new(0, 1, 0),
    FillTransparency = 0.5,

    OutlineColor = Color3.new(1, 1, 1),
    OutlineTransparency = 0;
};
local TARGETProxy = {
    FillColor = Color3.new(1, 0, 0),
    FillTransparency = 0.5,

    OutlineColor = Color3.new(1, 1, 1),
    OutlineTransparency = 0;
};
local HITBOXProxy = {
    Size = Vector3.new(2,2,1),
    Transparency = 1
};
local TARGETHITBOXProxy = {
    Size = Vector3.new(2,2,1),
    Transparency = 1
};

local Settings = setmetatable({}, {__index = SettingsProxy, __newindex = function(self, key, value)
    if key == "Target" then 
        for i,v in next, TARGETProxy do
            TARGETChanged:Fire(i,v);
        end;
    end;
    
    SettingsProxy[key] = value;
end});
Settings.INST = setmetatable({}, {__index = INSTProxy, __newindex = function(self, Key, Value)
    if INSTProxy[Key] then
        INSTChanged:Fire(Key, Value);
        INSTProxy[Key] = Value;
        
        return;
    end;
    
    return error(tostring(Key), " is not a valid key");
end});
Settings.TARGET = setmetatable({}, {__index = TARGETProxy, __newindex = function(self, Key, Value)
    if TARGETProxy[Key] then
        TARGETChanged:Fire(Key, Value);
        TARGETProxy[Key] = Value;
        
        return;
    end;
    
    return error(tostring(Key), " is not a valid key");
end});
Settings.HITBOX = setmetatable({}, {__index = HITBOXProxy, __newindex = function(self, Key, Value)
    if HITBOXProxy[Key] then
        HITBOXChanged:Fire(Key, Value);
        HITBOXProxy[Key] = Value;
        
        return;
    end;
    
    return error(tostring(Key), " is not a valid key");
end});
Settings.TARGETHITBOX = setmetatable({}, {__index = TARGETHITBOXProxy, __newindex = function(self, Key, Value)
    if TARGETHITBOXProxy[Key] then
        TARGETHITBOXChanged:Fire(Key, Value);
        TARGETHITBOXProxy[Key] = Value;
        
        return;
    end;
    
    return error(tostring(Key), " is not a valid key");
end});

local Highlight = {
    Active = true,
    Connections = {},
    Settings = Settings
};
Highlight.__index = Highlight;

Highlight.new = function(Character, Player)
    local cache = {};
    
    local Inst = Instance.new("Highlight");
    Inst.Adornee = Character;
    Inst.Parent = Character;
    
    if Settings.Target and Target and Player == Target then
        for k,v in next, TARGETProxy do
            Inst[k] = v;
            cache[k] = v;
        end;
    else
        for k, v in next, INSTProxy do
            Inst[k] = v;
            cache[k] = v;
        end;
    end;
    
    local SettingsCon; SettingsCon = INSTChanged:Connect(function(k,v)
        if cache[k] == v then return;end;
        if Settings.Target and Target and Target and Player == Target then return;end;
        Inst[k] = v;
        -- cache[k] = v;
    end);
    local TargetCon; TargetCon = TARGETChanged:Connect(function(k,v)
        if cache[k] == v then return;end;
        if not (Settings.Target and Target and Player == Target) then return;end;
        Inst[k] = v;
        -- cache[k] = v;
    end);
    Inst.Changed:Connect(function(P)
        cache[P] = Inst[P];
    end);

    
    local highlight = setmetatable({
        Active = true,
        Inst = Inst,
        Character = Character,
        SettingsCon = SettingsCon,
        TargetCon = TargetCon;
    }, Highlight);
    
    return highlight;
end;

Highlight.Destroy = function(self)
    if not self.Active then return;end;
    self.Active = false;
    self.SettingsCon:Disconnect();
    self.TargetCon:Disconnect();
    self.Inst:Destroy();
end;

local Extender = {};
Extender.__index = Extender;

Extender.new = function(Character, Player)
    local HRP = Character:FindFirstChild("HumanoidRootPart");
    
    local HitboxCon = HITBOXChanged:Connect(function(k,v)
        if not HRP then return;end;
        if Settings.Target and Target and Target and Player == Target then return;end;
        HRP[k] = v;
    end);
    local TargetHitboxCon = TARGETHITBOXChanged:Connect(function(k,v)
        if not HRP then return;end;
        if not (Settings.Target and Target and Target and Player == Target) then return;end;
        HRP[k] = v;
    end);

    local extender = setmetatable({
        Active = true,
        HitboxCon = HitboxCon,
        TargetHitboxCon = TargetHitboxCon,
        HRP = HRP,
    }, Extender);

    task.spawn(function()
        if not HRP then repeat task.wait();HRP = Character:FindFirstChild("HumanoidRootPart");until HRP;end;
        extender.HRP = HRP;

        if Settings.Target and Target and Player == Target then
            for k,v in next, TARGETHITBOXProxy do
                HRP[k] = v;
            end;
        else
            for k, v in next, HITBOXProxy do
                HRP[k] = v;
            end;
        end;
    end);

    return extender;
end;
Extender.Destroy = function(self)
    if not self.Active then return;end;
    self.Active = false;
    self.HitboxCon:Disconnect();
    self.TargetHitboxCon:Disconnect();
end;

local function GetCharacter(Player)
    return workspace:FindFirstChild(Player.Name);
end;

local PlayerObject = {};
PlayerObject.__index = PlayerObject;

PlayerObject.new = function(Player)
    if typeof(Player) ~= "Instance" or Player == LP then return;end;
    local playerobject = setmetatable({
        Active = true,
        Player = Player,
        Character = GetCharacter(Player) or Player.CharacterAdded:Wait();
    }, PlayerObject);

    task.spawn(function()
        playerobject.Highlight = Highlight.new(playerobject.Character, Player);
    end);
    task.spawn(function()
        playerobject.Extender = Extender.new(playerobject.Character, Player);
    end);

    local con = Player.CharacterAdded:Connect(function(Character)
        task.spawn(function()
            if playerobject.Highlight then playerobject.Highlight:Destroy();end;
            playerobject.Highlight = Highlight.new(Character, Player);
        end);
        task.spawn(function()
            if playerobject.Extender then playerobject.Extender:Destroy();end;
            playerobject.Extender = Extender.new(Character, Player);
        end);
    end);
    playerobject.CharacterAddedCon = con;

    PlayerObject[Player] = playerobject;

    return playerobject;
end;

PlayerObject.Destroy = function(self)
    if not self.Active then return;end;
    
    self.Active = false;
    if self.Highlight then self.Highlight:Destroy();end;
    if self.Extender then self.Extender:Destroy();end;
    self.CharacterAddedCon:Disconnect();
    
end;

Highlight.HandlePlayers = function()
    for I, Player in next, PlayerService:GetPlayers() do
        PlayerObject.new(Player);
    end;

    table.insert(Highlight.Connections, PlayerService.PlayerAdded:Connect(PlayerObject.new));
    table.insert(Highlight.Connections, PlayerService.PlayerRemoving:Connect(function(Player)
        if PlayerObject[Player] then
            PlayerObject[Player]:Destroy();
        end;
    end));
end;
Highlight.stop = function()
    if not Highlight.Active then return;end;
    
    Highlight.Active = false;
    for I, V in next, PlayerObject do
        if typeof(I) == "Instance" then
            V:Destroy();
        end;
    end;
    
    for i,v in next, Highlight.Connections do
        v:Disconnect();
    end;
end;

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Remotes = ReplicatedStorage.Remotes;
local HideTarget = Remotes.HideTarget;
local UpdateTarget = Remotes.UpdateTarget;

table.insert(Highlight.Connections, HideTarget.OnClientEvent:Connect(function()
    Target = nil;

    for k,v in next, INSTProxy do
        INSTChanged:Fire(k,v);
    end;
end));
table.insert(Highlight.Connections, UpdateTarget.OnClientEvent:Connect(function(T)
    Target = T;

    local p = PlayerObject[Target]
    local h = p and p.Highlight;
    
    if h then
        for k,v in next, TARGETProxy do
            h.Inst[k] = v;
        end;
    end;

    local e = p and p.Extender;
    if e then
        for k,v in next, TARGETHITBOXProxy do
            e.HRP[k] = v;
        end;
    end;
end));

Highlight.HandlePlayers();
shared.ShushHighlight = Highlight;
local Settings = shared.ShushHighlight.Settings;

Settings.HITBOX.Size = Vector3.new(5,5,5);
Settings.HITBOX.Transparency = 0.5;
Settings.TARGETHITBOX.Size = Vector3.new(15,15,15);
Settings.TARGETHITBOX.Transparency = 0.5;

Settings.INST.FillColor = Color3.fromRGB(222, 2, 222);
Settings.TARGET.OutlineColor = Color3.fromRGB(111, 11, 111);
--Tween
function GetTime(Distance, Speed)
    local Time = Distance / Speed
    return Time
end

function oreoTween(targetpart,oreospeed)
    local Speed = oreospeed  local Distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - targetpart.Position).magnitude local Time = GetTime(Distance, Speed) local TweenService = game:GetService("TweenService") local oreottable = TweenInfo.new( Time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out,  0, false, 0 ) local Tween = TweenService:Create(game.Players.LocalPlayer.Character.HumanoidRootPart,oreottable,{CFrame = targetpart.CFrame}) Tween:Play()
end 

spawn(function()
    while wait() do
        pcall(function()
            if game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == true then
                game.Workspace.Gravity = 0
                oreoTween(game.Workspace[game.Players.LocalPlayer.PlayerGui.ScreenGui:WaitForChild("UI"):WaitForChild("Target"):WaitForChild("TargetText").Text].HumanoidRootPart,30)
elseif game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == false then
    game.Workspace.Gravity = 196.2
end
end)
end
end)
--Stab aura
  local Player = game:GetService("Players").LocalPlayer
local wS = game:GetService("Workspace")

local ClosestPlayer = function()
    local Closest = nil
    local Distance = 9e9
    for i, v in next, game:GetService("Players"):GetPlayers() do
        if v.Name ~= Player.Name then
            if wS[v.Name] and wS[v.Name]:FindFirstChild("Humanoid") and wS[v.Name]:FindFirstChild("Humanoid").Health ~= 0 then
                local Magnitude = (Player.Character.Head.Position - wS[v.Name].Head.Position).Magnitude
                if Magnitude < Distance then
                    Closest = wS[v.Name]
                    Distance = Magnitude
                    end
                end
            end
        end
    return Closest
end
spawn(function()
        while wait() do
            repeat wait() until Player.Character:FindFirstChild("Head")
            if Player:DistanceFromCharacter(ClosestPlayer().Head.Position) <= 1000000.5 then
                Player.PlayerScripts.localknifehandler.HitCheck:Fire(ClosestPlayer())
                wait(.7)
            else
                wait()
            end
    end
end)

spawn(function()
    local function randompart()
        local hits = {
            0,
            1,
            2,
            -1,
            -2,
        }
        return hits[math.random(1, #hits)]
    end
    while wait() do
        pcall(function()
            if game.Players.LocalPlayer.Backpack:FindFirstChild("Knife") then
                for i, v in pairs(game.Players:GetPlayers()) do
                    if v.Name == game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.TargetText.Text then
                        if v.Name ~= game.Players.LocalPlayer.Name then
                            game.Players.LocalPlayer.Character.Humanoid:EquipTool(Game.Players.LocalPlayer.Backpack.Knife)
                            wait(2)
                            local Target = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.TargetText.Text
                            local x = game.Workspace[Target].HumanoidRootPart.Position.X + randompart()
                            local y = game.Workspace[Target].HumanoidRootPart.Position.Y + randompart()
                            local z = game.Workspace[Target].HumanoidRootPart.Position.Z + randompart()
                            local args = {
                                [1] = Vector3.new(x, y, z),
                                [2] = 0,
                                [3] = CFrame.new(0, 0, 0, math.huge, 0, 0, 0, math.huge, 0, 0, 0, math.huge)
                            }
                            game:GetService("ReplicatedStorage").Remotes.ThrowKnife:FireServer(unpack(args))
                            wait(.1)
                            game:GetService("Players").localPlayer.Character:FindFirstChildOfClass("Humanoid"):UnequipTools()
                            wait(.6)
                        end
                    end
                end
            end
        end)
    end
end)
--Noclip
local function DoIt2(yeah)
    pcall(function()
        yeah.CanQuery = true;
        local o = yeah.CanCollide;
        yeah.Touched:Connect(function(a)
            pcall(function()
                yeah.CanCollide = false;
                wait(1);
                yeah.CanCollide = o;
            end);
        end);
    end);
end;

local function DoIt(stuffs)
    for i,v in next, stuffs do
        DoIt2(v);
    end;
end;

workspace.DescendantAdded:Connect(function(c)
    if workspace:FindFirstChild("GameMap") and c:IsDescendantOf(workspace.GameMap) then
        if game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == true then
        DoIt2(c);
        end;
end;
end);
if workspace:FindFirstChild("GameMap") then
    if game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == true then
    DoIt(workspace.GameMap:GetDescendants());
end;
end;

spawn(function()
    while wait() do
        pcall(function()
           if workspace:FindFirstChild("GameMap") then
                   if game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.UI.Target.Visible == true then
              game.Workspace.GameMap:Destroy() 
                   end
          end
        end)
    end
    end) end);
